# This is the "abstract base class" for all agentic bot workflows.
# It contains all common logic and can be extended by concrete agent implementations.
#
# This workflow should not be called directly - use the concrete agent workflows instead.
name: Base Agent Workflow

on:
  workflow_call:
    inputs:
      # Agent Identity (required for all agents)
      agent_name:
        description: "Internal name of the agent (e.g., utop_agent, test_agent)"
        required: true
        type: string
      agent_image:
        description: "Docker image for the agent (e.g., utop_agent:latest)"
        required: true
        type: string
      agent_display_name:
        description: "Human-readable name shown in GitHub (e.g., UTOP Agent - Code Review)"
        required: true
        type: string

      # Trigger Configuration
      trigger_labels:
        description: "Comma-separated list of labels that trigger this agent"
        required: true
        type: string

      # Runtime Settings
      agent_timeout:
        description: "Timeout in seconds for agent execution"
        required: false
        type: string
        default: "600"
      max_retries:
        description: "Maximum number of retry attempts"
        required: false
        type: string
        default: "3"

      # Docker Configuration
      docker_registry:
        description: "Docker registry URL"
        required: false
        type: string
        default: "ghcr.io/ki-reply-gmbh/silicon-shoring-agentic-bots"

      # Agent-Specific Configuration
      required_secrets:
        description: "JSON array of required secret names for this agent"
        required: false
        type: string
        default: '["OPENAI_API_KEY"]'

      # Optional Features
      enable_langsmith:
        description: "Enable LangSmith tracing"
        required: false
        type: boolean
        default: false

    secrets:
      # Core GitHub Integration (required for all agents)
      GIT_ACCESS_TOKEN:
        description: "GitHub Personal Access Token"
        required: true
      GIT_USER_NAME:
        description: "GitHub username"
        required: true
      GIT_USER_EMAIL:
        description: "GitHub email"
        required: true

      # Agent-Specific Secrets (passed through dynamically)
      OPENAI_API_KEY:
        description: "OpenAI API key for LLM-powered agents"
        required: false
      SONAR_TOKEN:
        description: "SonarQube token for code analysis"
        required: false
      LANGCHAIN_API_KEY:
        description: "LangChain API key for enhanced tracing"
        required: false

jobs:
  execute-agent:
    name: ${{ inputs.agent_display_name }}
    runs-on: ubuntu-latest

    # Dynamic condition based on trigger labels
    # If trigger_labels is empty, '*', or 'all', trigger on all PRs
    # Otherwise, check if PR has any of the specified labels
    if: |
      github.event_name == 'pull_request' && 
      github.event.action != 'closed'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GIT_ACCESS_TOKEN }}

      # Validate agent configuration and secrets
      - name: Validate Agent Configuration
        run: |
          echo "üîç Validating agent configuration..."
          
          # Validate required inputs
          if [ -z "${{ inputs.agent_name }}" ] || [ -z "${{ inputs.agent_image }}" ] || [ -z "${{ inputs.trigger_labels }}" ]; then
            echo "‚ùå Error: Required inputs missing (agent_name, agent_image, trigger_labels)"
            exit 1
          fi
          
          # Validate core secrets
          if [ -z "${{ secrets.GIT_ACCESS_TOKEN }}" ] || [ -z "${{ secrets.GIT_USER_NAME }}" ] || [ -z "${{ secrets.GIT_USER_EMAIL }}" ]; then
            echo "‚ùå Error: Core GitHub secrets missing (GIT_ACCESS_TOKEN, GIT_USER_NAME, GIT_USER_EMAIL)"
            exit 1
          fi
          
          # Validate agent-specific secrets
          REQUIRED_SECRETS='${{ inputs.required_secrets }}'
          if echo "$REQUIRED_SECRETS" | jq -e '.[] | select(. == "OPENAI_API_KEY")' >/dev/null; then
            if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
              echo "‚ùå Error: OPENAI_API_KEY required but not provided"
              exit 1
            fi
          fi
          if echo "$REQUIRED_SECRETS" | jq -e '.[] | select(. == "SONAR_TOKEN")' >/dev/null; then
            if [ -z "${{ secrets.SONAR_TOKEN }}" ]; then
              echo "‚ùå Error: SONAR_TOKEN required but not provided"
              exit 1
            fi
          fi
          
          echo "‚úÖ Configuration validated - Agent: ${{ inputs.agent_name }}, Image: ${{ inputs.agent_image }}"

      # Check if PR has matching trigger labels or if no labels are required
      - name: Check Trigger Labels
        id: label-check
        run: |
          PR_LABELS="${{ join(github.event.pull_request.labels.*.name, ',') }}"
          TRIGGER_LABELS="${{ inputs.trigger_labels }}"

          echo "üìã PR Labels: $PR_LABELS"
          echo "üéØ Trigger Labels: $TRIGGER_LABELS"

          # Check if no label filtering is required
          if [ -z "$TRIGGER_LABELS" ] || [ "$TRIGGER_LABELS" = "*" ] || [ "$TRIGGER_LABELS" = "all" ]; then
            echo "üîì No label filtering required - agent will run on all PRs"
            echo "proceed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if PR has any of the required trigger labels
          IFS=',' read -ra LABEL_ARRAY <<< "$TRIGGER_LABELS"
          FOUND_TRIGGER=false

          for trigger_label in "${LABEL_ARRAY[@]}"; do
            # Remove whitespace from trigger label
            trigger_label=$(echo "$trigger_label" | xargs)
            
            # Skip empty labels
            if [ -z "$trigger_label" ]; then
              continue
            fi
            
            if [[ ",$PR_LABELS," == *",$trigger_label,"* ]]; then
              echo "‚úÖ Found matching trigger label: $trigger_label"
              FOUND_TRIGGER=true
              break
            fi
          done

          if [ "$FOUND_TRIGGER" = true ]; then
            echo "proceed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No matching trigger labels found. Agent will skip execution."
            echo "üí° Add one of these labels to trigger the agent: $TRIGGER_LABELS"
            echo "proceed=false" >> $GITHUB_OUTPUT
          fi

      # Setup Docker authentication and pull agent image
      - name: Setup Docker and Pull Image
        if: steps.label-check.outputs.proceed == 'true'
        run: |
          echo "ÔøΩ Setting up Docker and pulling agent image..."
          
          # Set registry URL and authenticate if needed
          if [ "${{ inputs.docker_registry }}" != "docker.io" ]; then
            echo "ÔøΩ Authenticating with ${{ inputs.docker_registry }}..."
            echo "${{ secrets.GIT_ACCESS_TOKEN }}" | docker login "${{ inputs.docker_registry }}" -u "${{ github.actor }}" --password-stdin
          fi
          
          # Determine full image name and pull
          if [ "${{ inputs.docker_registry }}" = "docker.io" ]; then
            FULL_IMAGE="${{ inputs.agent_image }}"
          else
            FULL_IMAGE="${{ inputs.docker_registry }}/${{ inputs.agent_image }}"
          fi
          
          echo "üì• Pulling agent image: $FULL_IMAGE"
          docker pull "$FULL_IMAGE"
          echo "FULL_IMAGE=$FULL_IMAGE" >> $GITHUB_ENV

      # Prepare standardized payload for all agents
      - name: Prepare Agent Payload
        if: steps.label-check.outputs.proceed == 'true'
        id: payload
        run: |
          echo "üì¶ Preparing agent payload..."

          # Safely handle PR title and body
          PR_TITLE='${{ github.event.pull_request.title }}'
          PR_BODY='${{ github.event.pull_request.body }}'

          # Handle null/empty values
          if [ -z "$PR_TITLE" ] || [ "$PR_TITLE" = "null" ]; then
            PR_TITLE="No title provided"
          fi

          if [ -z "$PR_BODY" ] || [ "$PR_BODY" = "null" ]; then
            PR_BODY="No description provided"
          fi

          # Create standardized payload for all agents
          PAYLOAD=$(jq -n \
            --arg number "${{ github.event.pull_request.number }}" \
            --arg title "$PR_TITLE" \
            --arg body "$PR_BODY" \
            --arg head_label "${{ github.event.pull_request.head.label }}" \
            --arg head_ref "${{ github.event.pull_request.head.ref }}" \
            --arg head_clone_url "${{ github.event.pull_request.head.repo.clone_url }}" \
            --arg base_label "${{ github.event.pull_request.base.label }}" \
            --arg base_ref "${{ github.event.pull_request.base.ref }}" \
            --arg diff_url "${{ github.event.repository.html_url }}/pull/${{ github.event.pull_request.number }}.diff" \
            '{
              number: ($number | tonumber),
              head: {
                label: $head_label,
                ref: $head_ref,
                repo: {
                  clone_url: $head_clone_url
                }
              },
              base: {
                label: $base_label,
                ref: $base_ref
              },
              title: $title,
              body: $body,
              diff_url: $diff_url
            }')

          # Validate JSON
          if ! echo "$PAYLOAD" | jq . >/dev/null 2>&1; then
            echo "‚ùå Error: Generated payload is not valid JSON"
            exit 1
          fi

          # Output for next step
          PAYLOAD_COMPACT=$(echo "$PAYLOAD" | jq -c .)
          echo "payload<<EOF" >> $GITHUB_OUTPUT
          echo "$PAYLOAD_COMPACT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "‚úÖ Payload prepared successfully"

      # Execute agent with retry logic and process results
      - name: Execute Agent
        if: steps.label-check.outputs.proceed == 'true'
        id: agent-execution
        run: |
          echo "üöÄ Executing ${{ inputs.agent_display_name }}..."
          
          # Set up environment variables
          export GIT_ACCESS_TOKEN="${{ secrets.GIT_ACCESS_TOKEN }}"
          export GIT_USER_NAME="${{ secrets.GIT_USER_NAME }}"
          export GIT_USER_EMAIL="${{ secrets.GIT_USER_EMAIL }}"
          
          # Optional environment variables
          [ -n "${{ secrets.OPENAI_API_KEY }}" ] && export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
          [ -n "${{ secrets.SONAR_TOKEN }}" ] && export SONAR_TOKEN="${{ secrets.SONAR_TOKEN }}"
          [ -n "${{ secrets.LANGCHAIN_API_KEY }}" ] && export LANGCHAIN_API_KEY="${{ secrets.LANGCHAIN_API_KEY }}"
          
          # LangSmith configuration
          if [ "${{ inputs.enable_langsmith }}" = "true" ]; then
            export LANGCHAIN_TRACING_V2="true"
            export LANGCHAIN_PROJECT="${{ inputs.agent_name }}_pr_${{ github.event.pull_request.number }}"
            echo "üîç LangSmith tracing enabled for project: $LANGCHAIN_PROJECT"
          fi
          
          # Create output directory and prepare payload
          mkdir -p /tmp/agent_output
          PAYLOAD='${{ steps.payload.outputs.payload }}'
          echo "$PAYLOAD" > /tmp/agent_output/payload.json
          
          # Execute agent with retry logic
          MAX_RETRIES=${{ inputs.max_retries }}
          TIMEOUT=${{ inputs.agent_timeout }}
          ATTEMPT=1
          SUCCESS=false
          EXIT_CODE=0
          
          while [ $ATTEMPT -le $MAX_RETRIES ] && [ "$SUCCESS" = false ]; do
            echo "üìä Attempt $ATTEMPT of $MAX_RETRIES"
            
            # Run the agent container
            if timeout "$TIMEOUT" docker run \
              --rm \
              -v /tmp/agent_output:/output \
              -e GIT_ACCESS_TOKEN \
              -e GIT_USER_NAME \
              -e GIT_USER_EMAIL \
              -e OPENAI_API_KEY \
              -e SONAR_TOKEN \
              -e LANGCHAIN_API_KEY \
              -e LANGCHAIN_TRACING_V2 \
              -e LANGCHAIN_PROJECT \
              "$FULL_IMAGE" \
              /output/payload.json > /tmp/agent_output/execution.log 2>&1; then
              
              echo "‚úÖ Agent execution completed successfully"
              SUCCESS=true
              EXIT_CODE=0
            else
              EXIT_CODE=$?
              echo "‚ùå Agent execution failed with exit code: $EXIT_CODE"
              
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "üîÑ Retrying in 30 seconds..."
                sleep 30
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          # Process and report results
          echo "üìä Processing execution results..."
          if [ "$SUCCESS" = "true" ]; then
            echo "‚úÖ ${{ inputs.agent_display_name }} completed successfully"
            
            # Check for result files
            RESULT_FILE=""
            for file in review.json result.json analysis.json tests.json output.json; do
              if [ -f "/tmp/agent_output/$file" ]; then
                RESULT_FILE="/tmp/agent_output/$file"
                echo "ÔøΩ Found result file: $file"
                break
              fi
            done
            
            if [ -n "$RESULT_FILE" ] && [ -f "$RESULT_FILE" ]; then
              echo "üìã Result summary:"
              if jq -r '.summary // .message // "Analysis completed"' "$RESULT_FILE" 2>/dev/null; then
                echo "‚úÖ Results processed successfully"
              else
                echo "üìä Results available (preview):"
                head -n 3 "$RESULT_FILE" 2>/dev/null || echo "Unable to preview results"
              fi
            fi
          else
            echo "‚ùå ${{ inputs.agent_display_name }} failed"
            [ $EXIT_CODE -eq 124 ] && echo "ÔøΩ Execution timed out - consider increasing timeout"
            [ -f /tmp/agent_output/execution.log ] && echo "üìã Execution log:" && tail -n 10 /tmp/agent_output/execution.log
          fi
          
          # Set outputs
          echo "success=$SUCCESS" >> $GITHUB_OUTPUT
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

      # Cleanup and logout
      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          rm -rf /tmp/agent_output

          # Logout from registry if authenticated
          if [ "${{ inputs.docker_registry }}" != "docker.io" ]; then
            docker logout "${{ inputs.docker_registry }}" 2>/dev/null || true
          fi

      # Set final workflow status
      - name: Set Final Status
        if: always() && steps.label-check.outputs.proceed == 'true'
        run: |
          if [ "${{ steps.agent-execution.outputs.success }}" = "true" ]; then
            echo "‚úÖ ${{ inputs.agent_display_name }} completed successfully"
            exit 0
          else
            echo "‚ùå ${{ inputs.agent_display_name }} failed"
            exit 1
          fi
