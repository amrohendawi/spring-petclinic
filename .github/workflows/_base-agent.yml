# Abstract Base Agent Workflow
#
# This is the "abstract base class" for all agentic bot workflows.
# It contains all common logic and can be extended by concrete agent implementations.
#
# This workflow should not be called directly - use the concrete agent workflows instead.

name: Base Agent Workflow

on:
  workflow_call:
    inputs:
      # Agent Identity (required for all agents)
      agent_name:
        description: "Internal name of the agent (e.g., utop_agent, test_agent)"
        required: true
        type: string
      agent_image:
        description: "Docker image for the agent (e.g., utop_agent:latest)"
        required: true
        type: string
      agent_display_name:
        description: "Human-readable name shown in GitHub (e.g., UTOP Agent - Code Review)"
        required: true
        type: string

      # Trigger Configuration
      trigger_labels:
        description: "Comma-separated list of labels that trigger this agent"
        required: true
        type: string

      # Runtime Settings
      agent_timeout:
        description: "Timeout in seconds for agent execution"
        required: false
        type: string
        default: "600"
      max_retries:
        description: "Maximum number of retry attempts"
        required: false
        type: string
        default: "3"

      # Docker Configuration
      docker_registry:
        description: "Docker registry URL"
        required: false
        type: string
        default: "ghcr.io/ki-reply-gmbh/silicon-shoring-agentic-bots"

      # Agent-Specific Configuration
      required_secrets:
        description: "JSON array of required secret names for this agent"
        required: false
        type: string
        default: '["OPENAI_API_KEY"]'

      # Optional Features
      enable_langsmith:
        description: "Enable LangSmith tracing"
        required: false
        type: boolean
        default: false

    secrets:
      # Core GitHub Integration (required for all agents)
      GIT_ACCESS_TOKEN:
        description: "GitHub Personal Access Token"
        required: true
      GIT_USER_NAME:
        description: "GitHub username"
        required: true
      GIT_USER_EMAIL:
        description: "GitHub email"
        required: true

      # Agent-Specific Secrets (passed through dynamically)
      OPENAI_API_KEY:
        description: "OpenAI API key for LLM-powered agents"
        required: false
      SONAR_TOKEN:
        description: "SonarQube token for code analysis"
        required: false
      LANGCHAIN_API_KEY:
        description: "LangChain API key for enhanced tracing"
        required: false

jobs:
  execute-agent:
    name: ${{ inputs.agent_display_name }}
    runs-on: ubuntu-latest

    # Dynamic condition based on trigger labels
    if: |
      github.event_name == 'pull_request' && 
      github.event.action != 'closed' && (
      contains(github.event.pull_request.labels.*.name, 'WRITE_TESTS')
      )

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GIT_ACCESS_TOKEN }}

      # Modular validation using composite action
      - name: Validate Agent Configuration
        uses: ./.github/actions/validate-agent-config
        with:
          agent_name: ${{ inputs.agent_name }}
          agent_image: ${{ inputs.agent_image }}
          trigger_labels: ${{ inputs.trigger_labels }}
          required_secrets: ${{ inputs.required_secrets }}
          git_access_token: ${{ secrets.GIT_ACCESS_TOKEN }}
          git_user_name: ${{ secrets.GIT_USER_NAME }}
          git_user_email: ${{ secrets.GIT_USER_EMAIL }}
          openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          sonar_token: ${{ secrets.SONAR_TOKEN }}

      # Check if PR has matching trigger labels
      - name: Check Trigger Labels
        id: label-check
        run: |
          PR_LABELS="${{ join(github.event.pull_request.labels.*.name, ',') }}"
          echo "üìã PR Labels: $PR_LABELS"
          echo "üéØ Trigger Labels: ${{ inputs.trigger_labels }}"

          # Convert comma-separated trigger labels to array and check each one
          IFS=',' read -ra LABEL_ARRAY <<< "${{ inputs.trigger_labels }}"
          FOUND_TRIGGER=false

          for trigger_label in "${LABEL_ARRAY[@]}"; do
            # Remove whitespace
            trigger_label=$(echo "$trigger_label" | xargs)
            if [[ ",$PR_LABELS," == *",$trigger_label,"* ]]; then
              echo "‚úÖ Found trigger label: $trigger_label"
              FOUND_TRIGGER=true
              break
            fi
          done

          if [ "$FOUND_TRIGGER" = true ]; then
            echo "proceed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No matching trigger labels found. Skipping agent execution."
            echo "proceed=false" >> $GITHUB_OUTPUT
          fi

      # Modular Docker authentication using composite action
      - name: Setup Docker Authentication
        if: steps.label-check.outputs.proceed == 'true'
        uses: ./.github/actions/setup-docker-auth
        with:
          docker_registry: ${{ inputs.docker_registry }}
          git_access_token: ${{ secrets.GIT_ACCESS_TOKEN }}
          github_actor: ${{ github.actor }}

      # Pull agent image
      - name: Pull Agent Image
        if: steps.label-check.outputs.proceed == 'true'
        run: |
          if [ "${{ inputs.docker_registry }}" = "docker.io" ]; then
            FULL_IMAGE="${{ inputs.agent_image }}"
          else
            FULL_IMAGE="${{ inputs.docker_registry }}/${{ inputs.agent_image }}"
          fi

          echo "üì• Pulling agent image: $FULL_IMAGE"
          docker pull "$FULL_IMAGE"
          echo "FULL_IMAGE=$FULL_IMAGE" >> $GITHUB_ENV

      # Prepare standardized payload for all agents
      - name: Prepare Agent Payload
        if: steps.label-check.outputs.proceed == 'true'
        id: payload
        run: |
          echo "üì¶ Preparing agent payload..."

          # Safely handle PR title and body
          PR_TITLE='${{ github.event.pull_request.title }}'
          PR_BODY='${{ github.event.pull_request.body }}'

          # Handle null/empty values
          if [ -z "$PR_TITLE" ] || [ "$PR_TITLE" = "null" ]; then
            PR_TITLE="No title provided"
          fi

          if [ -z "$PR_BODY" ] || [ "$PR_BODY" = "null" ]; then
            PR_BODY="No description provided"
          fi

          # Create standardized payload for all agents
          PAYLOAD=$(jq -n \
            --arg number "${{ github.event.pull_request.number }}" \
            --arg title "$PR_TITLE" \
            --arg body "$PR_BODY" \
            --arg head_label "${{ github.event.pull_request.head.label }}" \
            --arg head_ref "${{ github.event.pull_request.head.ref }}" \
            --arg head_clone_url "${{ github.event.pull_request.head.repo.clone_url }}" \
            --arg base_label "${{ github.event.pull_request.base.label }}" \
            --arg base_ref "${{ github.event.pull_request.base.ref }}" \
            --arg diff_url "${{ github.event.repository.html_url }}/pull/${{ github.event.pull_request.number }}.diff" \
            '{
              number: ($number | tonumber),
              head: {
                label: $head_label,
                ref: $head_ref,
                repo: {
                  clone_url: $head_clone_url
                }
              },
              base: {
                label: $base_label,
                ref: $base_ref
              },
              title: $title,
              body: $body,
              diff_url: $diff_url
            }')

          # Validate JSON
          if ! echo "$PAYLOAD" | jq . >/dev/null 2>&1; then
            echo "‚ùå Error: Generated payload is not valid JSON"
            exit 1
          fi

          # Output for next step
          PAYLOAD_COMPACT=$(echo "$PAYLOAD" | jq -c .)
          echo "payload<<EOF" >> $GITHUB_OUTPUT
          echo "$PAYLOAD_COMPACT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "‚úÖ Payload prepared successfully"

      # Modular agent execution using composite action
      - name: Execute Agent
        if: steps.label-check.outputs.proceed == 'true'
        id: agent-execution
        uses: ./.github/actions/execute-agent
        with:
          agent_name: ${{ inputs.agent_name }}
          agent_timeout: ${{ inputs.agent_timeout }}
          payload: ${{ steps.payload.outputs.payload }}
          agent_image: ${{ inputs.agent_image }}
          docker_registry: ${{ inputs.docker_registry }}
          git_access_token: ${{ secrets.GIT_ACCESS_TOKEN }}
          git_user_name: ${{ secrets.GIT_USER_NAME }}
          git_user_email: ${{ secrets.GIT_USER_EMAIL }}
          openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          sonar_token: ${{ secrets.SONAR_TOKEN }}
          langchain_api_key: ${{ secrets.LANGCHAIN_API_KEY }}
          enable_langsmith: ${{ inputs.enable_langsmith }}

      # Modular result processing using composite action
      - name: Process Results
        if: always() && steps.label-check.outputs.proceed == 'true'
        uses: ./.github/actions/process-results
        with:
          agent_name: ${{ inputs.agent_name }}
          execution_success: ${{ steps.agent-execution.outputs.success }}
          exit_code: ${{ steps.agent-execution.outputs.exit_code }}
          result_file: ${{ steps.agent-execution.outputs.result_file }}

      # Cleanup and logout
      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          rm -rf /tmp/agent_output

          # Logout from registry if authenticated
          if [ "${{ inputs.docker_registry }}" != "docker.io" ]; then
            docker logout "${{ inputs.docker_registry }}" 2>/dev/null || true
          fi

      # Set final workflow status
      - name: Set Final Status
        if: always() && steps.label-check.outputs.proceed == 'true'
        run: |
          if [ "${{ steps.agent-execution.outputs.success }}" = "true" ]; then
            echo "‚úÖ ${{ inputs.agent_display_name }} completed successfully"
            exit 0
          else
            echo "‚ùå ${{ inputs.agent_display_name }} failed"
            exit 1
          fi
